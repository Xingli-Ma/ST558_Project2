reports <- tibble(output_file, params)
# Generate reports
pwalk(reports, render, input = "ST558_Project2.Rmd")
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, error = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
require(rmarkdown)
require(knitr)
require(tidyverse)
require(dplyr)
require(ggplot2)
require(caret)
require(DT)
require(corrplot)
# Read and clean data
dayData <- read_csv("day.csv")
dayData <- filter(dayData, weekday == params$day)
dayData <- select(dayData, -c(instant, weekday))
dayData$dteday = as.Date(dayData$dteday, format = "%Y-%m-%d")
# Convert categorical variables to factors
cols <- c("season", "yr", "mnth", "holiday", "workingday", "weathersit")
dayData[cols] <- lapply(dayData[cols], factor)
# Split data to train and test sets
set.seed(1)
dayIndex <- createDataPartition(dayData$cnt, p = 0.7, list = FALSE)
dayTrain <- dayData[dayIndex, ]
dayTest <- dayData[-dayIndex, ]
# Summarize training data set
datatable(dayTrain)
# Display the training data set
kable(summary(dayTrain))
# Summarize training data set
datatable(dayTrain)
# Display the training data set
kable(summary(select(dayTrain, c(temp, atemp, hum, windspeed, casual,
registered, cnt))))
# Renaming factor levels
dayTrainCopy <- dayTrain
levels(dayTrainCopy$workingday) <- c("neither weekend nor holiday", "weekend or holiday")
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$workingday, summary)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$workingday, summary)
class(tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$workingday, summary))
data.frame(tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$workingday, summary))
tapply(X=dayTrain$cnt, INDEX=dayTrain$weathersit, summary)
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit)
# Contingency table comparing number of users by season
dayTrainCopy <- dayTrain
dayTrainCopy$cntRange <- cut(dayTrainCopy$cnt, c(0, 2000, 4000, 6000))
levels(dayTrainCopy$cntRange) = c("<2000", "2001-4000", "4001-6000", ">6000")
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
twoWayTab <- table(dayTrainCopy$season,
dayTrainCopy$cntRange)
# Comparing Number of Users by Season
kable(twoWayTab, caption = 'Season and Total Number of Users')
# Subset by columns we want to analyze
userCountStats <- dayTrain[ , c("casual", "registered", "cnt", "yr")]
colnames(userCountStats) <- c("Casual Users", "Registered Users", "Total Users", "Year")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 0)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2011")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 1)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2012")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$yr) <- list("2011" = 0,
"2012" = 1)
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
g <- ggplot(dayTrainCopy, aes(x = yr, fill = season))
g + geom_bar(aes(weight = cnt), position = "stack") +
labs(x = "Year", y = "Total User Count") +
scale_fill_discrete(name = "Season")
ggplot(dayTrain, aes(x = temp, y = cnt)) +
geom_point(stat = "identity") +
geom_smooth(data = dayTrain, aes(x = temp, y = cnt), method = "lm") +
labs(x = "Temperature", y = "Total User Count")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$mnth) <- list("Jan" = 1, "Feb" = 2, "Mar" = 3, "Apr" = 4,
"May" = 5, "Jun" = 6, "Jul" = 7, "Aug" = 8,
"Sep" = 9, "Oct" = 10, "Nov" = 11, "Dec" = 12)
g <- ggplot(dayTrainCopy, aes(x = mnth, y = cnt))
g + geom_boxplot() +
geom_point(aes(col = mnth), alpha = 1, size = 1, position = "jitter") +
labs(title = "Boxplot for Number of Users by Month",
x = "Month",
y = "Number of Users",
color='Month')
# Create correlation matrix
CM <- cor(dayTrain[, c("temp", "atemp", "hum", "windspeed", "cnt")])
# Plot the correlation matrix
corrplot(round(CM,2), method="circle")
# Create a histogram plot for total rental bikes
h <- ggplot(dayTrain, aes(x=cnt))
h + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes")
# Create a histogram plot for total rental bikes
dayTrainCopy <- dayTrain
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
d <- ggplot(dayTrainCopy, aes(x=cnt))
d + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
facet_wrap(~ season, ncol = 2) +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes by Season")
# Define training control
trctrl <- trainControl(method = "cv", number = 10)
# Set seed for reproducible
set.seed(123)
# Fit the linear regression model with cnt as response and weather data as predictors
fit1 <- train(cnt ~ weathersit + temp + atemp + hum + windspeed +
I(`temp`^2) + I(`atemp`^2) + I(`hum`^2) +
I(`windspeed`^2),
data = select(dayTrain, -c(registered, casual)),
method = "glm",
preProcess = c("center", "scale"),
trControl = trctrl)
fit1
dayTrain$weathersit
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit) <- list(
"Clear, Few clouds, Partly cloudy" = 1,
"Mist, Cloudy" = 2,
"Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds" = 3
)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$weathersit, summary)
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit) <- list(
"Clear, Few clouds, Partly cloudy" = 1,
"Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist" = 2,
"Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds" = 3
)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$weathersit, summary)
tapply(X=dayTrain$cnt, INDEX=dayTrain$weathersit, summary)
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit) <- list(
"Clear, Few clouds, Partly cloudy" = 1,
"Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist" = 2,
"Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds" = 3
)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$weathersit, summary)
dayTrainCopy$cnt
dayTrain
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit) <- list(
"Clear, Few clouds, Partly cloudy" = 1,
"Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist" = 2,
"Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds" = 3
)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$weathersit, summary)
# Contingency table comparing number of users by season
dayTrainCopy <- dayTrain
dayTrainCopy$cntRange <- cut(dayTrainCopy$cnt, c(0, 2000, 4000, 6000))
levels(dayTrainCopy$cntRange) = c("<2000", "2001-4000", "4001-6000", ">6000")
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
twoWayTab <- table(dayTrainCopy$season,
dayTrainCopy$cntRange)
# Comparing Number of Users by Season
kable(twoWayTab, caption = 'Season and Total Number of Users')
# Subset by columns we want to analyze
userCountStats <- dayTrain[ , c("casual", "registered", "cnt", "yr")]
colnames(userCountStats) <- c("Casual Users", "Registered Users", "Total Users", "Year")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 0)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2011")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 1)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2012")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$yr) <- list("2011" = 0,
"2012" = 1)
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
g <- ggplot(dayTrainCopy, aes(x = yr, fill = season))
g + geom_bar(aes(weight = cnt), position = "stack") +
labs(x = "Year", y = "Total User Count") +
scale_fill_discrete(name = "Season")
ggplot(dayTrain, aes(x = temp, y = cnt)) +
geom_point(stat = "identity") +
geom_smooth(data = dayTrain, aes(x = temp, y = cnt), method = "lm") +
labs(x = "Temperature", y = "Total User Count")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$mnth) <- list("Jan" = 1, "Feb" = 2, "Mar" = 3, "Apr" = 4,
"May" = 5, "Jun" = 6, "Jul" = 7, "Aug" = 8,
"Sep" = 9, "Oct" = 10, "Nov" = 11, "Dec" = 12)
g <- ggplot(dayTrainCopy, aes(x = mnth, y = cnt))
g + geom_boxplot() +
geom_point(aes(col = mnth), alpha = 1, size = 1, position = "jitter") +
labs(title = "Boxplot for Number of Users by Month",
x = "Month",
y = "Number of Users",
color='Month')
# Create correlation matrix
CM <- cor(dayTrain[, c("temp", "atemp", "hum", "windspeed", "cnt")])
# Plot the correlation matrix
corrplot(round(CM,2), method="circle")
# Create a histogram plot for total rental bikes
h <- ggplot(dayTrain, aes(x=cnt))
h + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes")
# Create a histogram plot for total rental bikes
dayTrainCopy <- dayTrain
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
d <- ggplot(dayTrainCopy, aes(x=cnt))
d + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
facet_wrap(~ season, ncol = 2) +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes by Season")
# Define training control
trctrl <- trainControl(method = "cv", number = 10)
# Set seed for reproducible
set.seed(123)
# Fit the linear regression model with cnt as response and weather data as predictors
fit1 <- train(cnt ~ weathersit + temp + atemp + hum + windspeed +
I(`temp`^2) + I(`atemp`^2) + I(`hum`^2) +
I(`windspeed`^2),
data = select(dayTrain, -c(registered, casual)),
method = "glm",
preProcess = c("center", "scale"),
trControl = trctrl)
fit1
set.seed(123)
# Fit Poisson model on traing set
fit2 <- train(cnt ~ ., data = select(dayTrain, -c(registered, casual)),
method = "glm",
family = "poisson",
preProcess = c("center", "scale"),
trControl = trctrl)
fit2
set.seed(123)
# Fit the random forest model on training set
fit3 <- train(cnt ~ ., data = select(dayTrain, -c(registered, casual)),
method = "rf",
preProcess = c("center", "scale"),
trControl = trctrl)
fit3
set.seed(123)
# Fit the boosted tree model on training set
fit4 <- train(cnt ~., data = select(dayTrain, -c(registered, casual)),
method = "gbm",
trControl = trctrl, # Passing trainControl() method
preProcess = c("center", "scale"), # Standardize variables
verbose = FALSE)
fit4
dayTestFiltered <- select(dayTest, -c(registered, casual))
predfit1 <- predict(fit1, newdata = dayTestFiltered)
predfit2 <- predict(fit2, newdata = dayTestFiltered)
predfit3 <- predict(fit3, newdata = dayTestFiltered)
predfit4 <- predict(fit4, newdata = dayTestFiltered)
testResults <- rbind(postResample(predfit1, dayTestFiltered$cnt),
postResample(predfit2, dayTestFiltered$cnt),
postResample(predfit3, dayTestFiltered$cnt),
postResample(predfit4, dayTestFiltered$cnt))
testResults <- data.frame(testResults)
row.names(testResults) <- c("Linear Regression",
"Poisson Regression",
"Random Forest",
"Boosted Tree")
# show RMSE values for all models
kable(testResults)
fit3$results
# Find the best model with lowest RMSE value
bestModel <- rownames(testResults[testResults$RMSE == min(testResults$RMSE), ])
print(paste("Best model to use:", bestModel))
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, error = TRUE, warning = FALSE, message = FALSE, cache = TRUE)
require(rmarkdown)
require(knitr)
require(tidyverse)
require(dplyr)
require(ggplot2)
require(caret)
require(DT)
require(corrplot)
# Read and clean data
dayData <- read_csv("day.csv")
dayData <- filter(dayData, weekday == params$day)
dayData <- select(dayData, -c(instant, weekday))
dayData$dteday = as.Date(dayData$dteday, format = "%Y-%m-%d")
# Convert categorical variables to factors
cols <- c("season", "yr", "mnth", "holiday", "workingday", "weathersit")
dayData[cols] <- lapply(dayData[cols], factor)
# Split data to train and test sets
set.seed(1)
dayIndex <- createDataPartition(dayData$cnt, p = 0.7, list = FALSE)
dayTrain <- dayData[dayIndex, ]
dayTest <- dayData[-dayIndex, ]
# Summarize training data set
datatable(dayTrain)
# Display the training data set
kable(summary(select(dayTrain, c(temp, atemp, hum, windspeed, casual,
registered, cnt))))
# Renaming factor levels
dayTrainCopy <- dayTrain
levels(dayTrainCopy$workingday) <- c("neither weekend nor holiday", "weekend or holiday")
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$workingday, summary)
dayTrainCopy <- dayTrain
levels(dayTrainCopy$weathersit) <- list(
"Clear, Few clouds, Partly cloudy" = 1,
"Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist" = 2,
"Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds" = 3
)
tapply(X=dayTrainCopy$cnt, INDEX=dayTrainCopy$weathersit, summary)
# Contingency table comparing number of users by season
dayTrainCopy <- dayTrain
dayTrainCopy$cntRange <- cut(dayTrainCopy$cnt, c(0, 2000, 4000, 6000))
levels(dayTrainCopy$cntRange) = c("<2000", "2001-4000", "4001-6000", ">6000")
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
twoWayTab <- table(dayTrainCopy$season,
dayTrainCopy$cntRange)
# Comparing Number of Users by Season
kable(twoWayTab, caption = 'Season and Total Number of Users')
# Subset by columns we want to analyze
userCountStats <- dayTrain[ , c("casual", "registered", "cnt", "yr")]
colnames(userCountStats) <- c("Casual Users", "Registered Users", "Total Users", "Year")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 0)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2011")
# Function for summary statistics for casual and registered user counts
userCountsFiltered <- filter(userCountStats, Year == 1)[, -4]
kable(do.call(cbind, lapply(userCountsFiltered, summary, digits = 3)),
caption = "Summary of 2012")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$yr) <- list("2011" = 0,
"2012" = 1)
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
g <- ggplot(dayTrainCopy, aes(x = yr, fill = season))
g + geom_bar(aes(weight = cnt), position = "stack") +
labs(x = "Year", y = "Total User Count") +
scale_fill_discrete(name = "Season")
ggplot(dayTrain, aes(x = temp, y = cnt)) +
geom_point(stat = "identity") +
geom_smooth(data = dayTrain, aes(x = temp, y = cnt), method = "lm") +
labs(x = "Temperature", y = "Total User Count")
dayTrainCopy <- dayTrain
levels(dayTrainCopy$mnth) <- list("Jan" = 1, "Feb" = 2, "Mar" = 3, "Apr" = 4,
"May" = 5, "Jun" = 6, "Jul" = 7, "Aug" = 8,
"Sep" = 9, "Oct" = 10, "Nov" = 11, "Dec" = 12)
g <- ggplot(dayTrainCopy, aes(x = mnth, y = cnt))
g + geom_boxplot() +
geom_point(aes(col = mnth), alpha = 1, size = 1, position = "jitter") +
labs(title = "Boxplot for Number of Users by Month",
x = "Month",
y = "Number of Users",
color='Month')
# Create correlation matrix
CM <- cor(dayTrain[, c("temp", "atemp", "hum", "windspeed", "cnt")])
# Plot the correlation matrix
corrplot(round(CM,2), method="circle")
# Create a histogram plot for total rental bikes
h <- ggplot(dayTrain, aes(x=cnt))
h + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes")
# Create a histogram plot for total rental bikes
dayTrainCopy <- dayTrain
levels(dayTrainCopy$season) <- list("Winter" = 1,
"Spring" = 2,
"Summer" = 3,
"Fall" = 4)
d <- ggplot(dayTrainCopy, aes(x=cnt))
d + geom_histogram(bins=20, aes(y=..density..)) +
geom_density(stat="density", adjust=0.4, lwd=2, colour= "red") +
facet_wrap(~ season, ncol = 2) +
xlab("Total Rental Bikes") + ylab("Density") +
ggtitle("Histogram for Total Rental Bikes by Season")
# Define training control
trctrl <- trainControl(method = "cv", number = 10)
# Set seed for reproducible
set.seed(123)
# Fit the linear regression model with cnt as response and weather data as predictors
fit1 <- train(cnt ~ weathersit + temp + atemp + hum + windspeed +
I(`temp`^2) + I(`atemp`^2) + I(`hum`^2) +
I(`windspeed`^2),
data = select(dayTrain, -c(registered, casual)),
method = "glm",
preProcess = c("center", "scale"),
trControl = trctrl)
fit1
set.seed(123)
# Fit Poisson model on traing set
fit2 <- train(cnt ~ ., data = select(dayTrain, -c(registered, casual)),
method = "glm",
family = "poisson",
preProcess = c("center", "scale"),
trControl = trctrl)
fit2
set.seed(123)
# Fit the random forest model on training set
fit3 <- train(cnt ~ ., data = select(dayTrain, -c(registered, casual)),
method = "rf",
preProcess = c("center", "scale"),
trControl = trctrl)
fit3
set.seed(123)
# Fit the boosted tree model on training set
fit4 <- train(cnt ~., data = select(dayTrain, -c(registered, casual)),
method = "gbm",
trControl = trctrl, # Passing trainControl() method
preProcess = c("center", "scale"), # Standardize variables
verbose = FALSE)
fit4
dayTestFiltered <- select(dayTest, -c(registered, casual))
predfit1 <- predict(fit1, newdata = dayTestFiltered)
predfit2 <- predict(fit2, newdata = dayTestFiltered)
predfit3 <- predict(fit3, newdata = dayTestFiltered)
predfit4 <- predict(fit4, newdata = dayTestFiltered)
testResults <- rbind(postResample(predfit1, dayTestFiltered$cnt),
postResample(predfit2, dayTestFiltered$cnt),
postResample(predfit3, dayTestFiltered$cnt),
postResample(predfit4, dayTestFiltered$cnt))
testResults <- data.frame(testResults)
row.names(testResults) <- c("Linear Regression",
"Poisson Regression",
"Random Forest",
"Boosted Tree")
# show RMSE values for all models
kable(testResults)
# Find the best model with lowest RMSE value
bestModel <- rownames(testResults[testResults$RMSE == min(testResults$RMSE), ])
print(paste("Best model to use:", bestModel))
library(rmarkdown)
library(tidyverse)
# Generate report for each day below
weekdays <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
"Saturday")
# Numbers corresponding to days; 0 = Sunday, 1 = Monday, etc.
dayNum <- c(0:6)
# Create file names
output_file <- paste0(weekdays, "Analysis.md")
# Create a list for each day
params = lapply(dayNum, FUN = function(x){list(day = x)})
# Put into a data frame
reports <- tibble(output_file, params)
# Generate reports
pwalk(reports, render, input = "ST558_Project2.Rmd")
library(rmarkdown)
library(tidyverse)
# Generate report for each day below
weekdays <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
"Saturday")
# Numbers corresponding to days; 0 = Sunday, 1 = Monday, etc.
dayNum <- c(0:6)
# Create file names
output_file <- paste0(weekdays, "Analysis.md")
# Create a list for each day
params = lapply(dayNum, FUN = function(x){list(day = x)})
# Put into a data frame
reports <- tibble(output_file, params)
# Generate reports
pwalk(reports, render, input = "ST558_Project2.Rmd")
library(rmarkdown)
library(tidyverse)
# Generate report for each day below
weekdays <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
"Saturday")
# Numbers corresponding to days; 0 = Sunday, 1 = Monday, etc.
dayNum <- c(0:6)
# Create file names
output_file <- paste0(weekdays, "Analysis")
# Create a list for each day
params = lapply(dayNum, FUN = function(x){list(day = x)})
# Put into a data frame
reports <- tibble(output_file, params)
# Generate reports
pwalk(reports, render, input = "ST558_Project2.Rmd")
install.packages("shiny")
library(rmarkdown)
library(tidyverse)
# Generate report for each day below
weekdays <- c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday",
"Saturday")
# Numbers corresponding to days; 0 = Sunday, 1 = Monday, etc.
dayNum <- c(0:6)
# Create file names
output_file <- paste0(weekdays, "Analysis")
# Create a list for each day
params = lapply(dayNum, FUN = function(x){list(day = x)})
# Put into a data frame
reports <- tibble(output_file, params)
# Generate reports
pwalk(reports, render, input = "ST558_Project2.Rmd")
